# ADR-001: Выбор архитектурного стиля — модульный монолит + выделенный ML-сервис

**Статус:** accepted
**Дата:** 2025-12-05
**Проект:** «Цифровой Ассистент Студента»

---

## Контекст

Проект «Цифровой Ассистент Студента» — это веб-система для поддержки выбора проектов КР/ВКР студентами ФКН с использованием:

- семантического поиска;
- рекомендательной системы по интересам;
- фильтрации по технологиям/направлениям.

Основные пользователи:
студенты, внешние/внутренние заказчики, сотрудники ЦППРП.

Ключевые требования:

- **Функциональные (MVP):**

  - импорт и парсинг таблиц проектов (Google/Yandex Sheets, XLSX);
  - просмотр/фильтрация/поиск по проектам;
  - ЛК студента (избранное, интересы, рекомендации, заявки);
  - ЛК заказчика (создание/редактирование проектов, просмотр заявок);
  - ЛК ЦППРП (утверждение проектов, дедлайны, шаблоны).

- **Нефункциональные:**

  - пик нагрузки осенью (~1.5–2k студентов, ~1.5–1.7k проектов);
  - важна сохранность данных проектов и заявок;
  - приемлема **eventual consistency** рекомендаций;
  - деплой на серверах вуза (ограничения инфраструктуры пока неизвестны);
  - срок разработки ~15 недель, команда 4 человека (ML/MLops, backend, data, frontend).

Необходимо выбрать архитектурный стиль, который:

- реалистичен для команды и сроков;
- поддерживает модульность по домену;
- позволяет развивать ML-часть независимо;
- не перегружает проект сложностью микросервисов.

## Решение

Принять архитектурный стиль:

> **Модульный монолит (Python) + выделенный ML/LLM-сервис рекомендаций и семантического поиска.**

### Кратко

1. **Backend** — одно приложение (деплой-юнит) на Python/FastAPI, логически разбитое на доменные модули:

   - `users` — пользователи, роли, профили;
   - `projects` — карточки проектов, статусы, дедлайны, импорт из таблиц;
   - `applications` — заявки, статусы, workflow;
   - `cpprp` — настройки ОП, дедлайны, шаблоны документов;
   - `integrations` — SSO, Sheets, LMS/ЕЛК;
   - `recs` — фасад над ML-сервисом (поиск/рекомендации).

2. **База данных** — PostgreSQL с подходом **schema-per-module**:

   - схемы `users`, `projects`, `applications`, `cpprp`, `ml` и т.п.;
   - межмодульные связи — через суррогатные ключи (ID), без прямых join между схемами в прикладном коде; данные других модулей получаются через их API/сервисы.

3. **ML/LLM-сервис** — отдельный сервис:

   - отвечает за вычисление embeddings, индексов для семантического поиска и рекомендательной логики;
   - не хранит “истину”, читает свежие данные из PostgreSQL.

4. **Обновление данных для рекомендаций** — через очередь событий:

   - backend при изменении сущностей, важных для рекомендаций (`project_updated`, `student_interests_updated`), публикует события в очередь;
   - ML-сервис читает события, запрашивает актуальные данные из БД и обновляет свои индексы;
   - обеспечивается **eventual consistency**, достаточная для предметной области.

---

## Обоснование

1. **Против микросервисов:**

   - команда и срок ограничены (4 человека, 15 недель);
   - микросервисы добавляют заметный overhead: инфраструктура, деплой, трассировка, контрактная совместимость;
   - вся предметная область тесно связана (проекты ↔ заявки ↔ студенты ↔ ЦППРП).

2. **В пользу модульного монолита:**

   - один деплой-юнит упрощает эксплуатацию на серверах вуза;
   - доменная модульность (users/projects/applications/cpprp/integrations) сохраняет структуру и снижает связность;
   - проще реализовать MVP по этапам Min1–Min4, не тратя ресурсы на распределённую архитектуру.

3. **Отдельный ML-сервис:**

   - ML-часть имеет отдельный жизненный цикл (эксперименты, обучение, ресурсоёмкие модели);
   - может требовать специфических ресурсов (GPU/ускорители), отличающихся от основного backend’а;
   - выделение в отдельный сервис упрощает работу ML/MLops без ломки основного приложения.

4. **Schema-per-module и суррогатные ключи:**

   - модульность отражена на уровне БД, что делает границы контекстов явными;
   - отсутствие прямых join между схемами и работа через ID + сервисы упрощают последующее потенциальное выделение модулей в отдельные сервисы, если проект вырастет.

---

## Последствия

### Положительные

- Быстрая и реалистичная разработка MVP при сохранении архитектурной дисциплины.
- Возможность развивать и масштабировать ML-часть независимо от остального кода.
- Меньше инфраструктурной сложности по сравнению с полноформатными микросервисами.
- Чёткие доменные границы в коде и БД упрощают поддержку и эволюцию системы.

### Отрицательные / риски

- Всё равно один процесс: нельзя “сложно” масштабировать отдельные доменные модули без выделения в сервис.
- Требуется дисциплина команды (не нарушать модульные границы, не плодить кросс-зависимости и “левые join’ы”).
- Нужен отдельный компонент очереди сообщений и его поддержка (пусть и относительно простая).

---

## Рассмотренные альтернативы

1. **Простой монолит:**

   - проще старт, но быстро превратимся в “big ball of mud” при добавлении ролей, workflow и интеграций;
   - хуже подготовлен к долгосрочному развитию.
   - правльно организовав модульный монолит в будующем при необходимости можно будет разъехаться по сервиса, но опять таки полезность не прозрачна на данном этапе

2. **Микроядерная архитектура:**

   - разумно в случае, если данная платформа в будущем станет "хабом" с кучей дополнительных сервисов, что на данном этапе не предвидится
   - на данном этапе проекта важно показать жизнеспособный продукт, а не застрять на этапе планировки
   - разумно локально применить микроядерный подход в подсистеме рекомендаций например

3. **Полноценная микросервисная архитектура:**

   - избыточна для текущих масштабов и сроков;
   - требует сложной инфраструктуры и сильно увеличивает нагрузку на команду.
